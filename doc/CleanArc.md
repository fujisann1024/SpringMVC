# クリーンアーキテクチャ

## 値オブジェクト

<details>

<summary>値オブジェクト</summary>

### 概要

- 同一性（ID）を持たず、値の集合＝状態だけで定義されるオブジェクト
- 不変（immutable）が原則。生成時に自己検証で不正値を弾き、以後は変更不可（差し替えで表現）
- 等価性は“値で比較”（equals/hashCode は全フィールド由来）
  - 例：Email、Money(額+通貨)、DateRange(開始/終了)、PhoneNumber、Coordinate、Percentage など
- エンティティとの違い：エンティティは“ID で同一”、VO は“値が同じなら同一”

### 使用用途

- ドメインの語彙を型として表現し、“プリミティブ執着（int/String 乱用）”を解消
- 不変条件・ルールのカプセル化（例：メール書式、金額の端数処理、期間の整合）
- 複数プロパティの意味的まとまりを一つの型に（例：住所、氏名、期間）
- 入力境界のバリデーションを集中（アプリ層やコントローラからロジックを追い出す）
- エンティティの属性・ユースケースの入出力・ドメインサービスの引数/戻り値に広く使う
- 永続化：JPA なら @Embeddable、MyBatis なら TypeHandler 等で値として埋め込み

### メリット

- 不変＋自己検証で不正状態を表現できない設計になり、バグ低減
- 意味のある型により可読性・意図表現が向上（レビュー/保守が楽）
- ロジックの局所化（端数・比較・マージなどを VO 内に集約）で再利用性 UP
- テスト容易：外部依存がなくユニットテストが軽い

### デメリット

- 型の数が増える → 学習コスト・ボイラープレート増
- 永続化/シリアライズのマッピングがやや面倒（ORM/JSON の変換層が必要）
- 生成コスト／GC が微増（大量生成パスでは注意。ただし早期最適化は不要）
- 不変ゆえに差し替えが必要（更新ではなく新インスタンスを返す設計）

</details>
